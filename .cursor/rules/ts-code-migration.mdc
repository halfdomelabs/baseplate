---
description: 
globs: 
alwaysApply: false
---
# Baseplate TypeScript Generator Migration Guide

This guide provides detailed instructions for migrating from the old TypeScript generator system to the new fragment-based approach. The new system offers improved composability, type safety, and maintainability.

## Core Conceptual Changes

The migration represents a shift from imperative, mutable operations to declarative, functional composition:

| Old System | New System |
|------------|------------|
| `TypescriptCodeBlock` | `TsCodeFragment` |
| String-based imports | `tsImportBuilder` |
| Custom provider interfaces | Config providers with FieldMaps |
| Manual template rendering | Standardized template system |
| Imperative modifications | Declarative compositions |

## 1. Migrating Provider Types

### Old Approach
```typescript
// Define custom provider interface
export interface ReactSentryProvider {
  addSentryScopeAction(block: TypescriptCodeBlock): void;
}

// Create provider type
export const reactSentryProvider = createProviderType<ReactSentryProvider>('react-sentry');

// Provider implementation in task
providers: {
  reactSentry: {
    addSentryScopeAction(block) {
      sentryFile.addCodeBlock('SENTRY_SCOPE_ACTIONS', block);
    }
  }
}
```

### New Approach with Config Providers
```typescript
// Create a config provider task with a FieldMap
const [setupTask, reactSentryConfigProvider, reactSentryConfigValuesProvider] =
  createConfigProviderTask(
    (t) => ({
      sentryScopeActions: t.map<string, TsCodeFragment>(),
    }),
    {
      prefix: 'react-sentry',
      configScope: projectScope,
    }
  );

// Export the provider
export { reactSentryConfigProvider };

// In a consumer task
reactSentryConfig.sentryScopeActions.set('key', fragment);
```

### Migration Rules for Providers

1. Identify the provider's core functionality:
   - For collections, use `t.map<K, V>()`, `t.array<T>()`, etc.
   - For single values, use `t.scalar<T>(defaultValue)`
   - For objects, use `t.object<T>(defaultValue)`

2. Replace provider methods with FieldMap operations:
   - `add*()` methods → `array.push()` or `map.set()`
   - `set*()` methods → `scalar.set()` or `map.set()`
   - `get*()` methods → Access from `configValuesProvider`

3. Structure your task:
   - Export the `setupTask` from `createConfigProviderTask`
   - Export the config provider (for mutation)
   - Export the values provider (for reading)

## 2. Migrating Code Fragments

### Old Approach
```typescript
const headerBlock = TypescriptCodeUtils.createBlock(
  `function parseData() { 
    // code
  }`,
  "import { DataType } from '@/types'"
);
```

### New Approach
```typescript
const headerFragment = tsCodeFragment(
  `function parseData() { 
    // code
  }`,
  tsImportBuilder(['DataType']).from('@/types')
);
```

### Advanced Fragment With Hoisted Content
```typescript
// New approach with hoisted fragments
const fragment = tsCodeFragment(
  `mainFunction() {
    // Main implementation
  }`,
  tsImportBuilder(['utility']).from('@/utils'),
  {
    hoistedFragments: [
      tsHoistedFragment(
        helperFragment,
        'unique-helper-key',
        'afterImports'
      )
    ]
  }
);
```

### Using TsCodeUtils

The `TsCodeUtils` object provides utility functions for working with code fragments:

```typescript
// Merge multiple fragments
const merged = TsCodeUtils.mergeFragments(
  fragmentsMap,
  '\n\n' // separator
);

// Format as template
const formatted = TsCodeUtils.formatFragment(
  'function NAME(PARAMS) {\n  BODY\n}',
  {
    NAME: 'processUser',
    PARAMS: 'user: User',
    BODY: bodyFragment
  }
);

// Create object literal
const options = TsCodeUtils.mergeFragmentsAsObject({
  timeout: '5000',
  formatter: formatterFragment,
  logging: 'true'
});

// Template literal style
const result = TsCodeUtils.template`
  export function handler() {
    ${logicFragment}
    return ${resultFragment};
  }
`;
```

## 3. Migrating Import Declarations

### Old Approach
```typescript
"import { GraphQLError } from 'graphql'"
"import React, { useState, useEffect } from 'react'"
```

### New Approach
```typescript
// Named imports
tsImportBuilder(['GraphQLError']).from('graphql')

// Multiple named imports
tsImportBuilder()
  .named('useState')
  .named('useEffect')
  .from('react')

// Default import
tsImportBuilder()
  .default('React')
  .from('react')

// Combined default and named imports
tsImportBuilder()
  .default('React')
  .named('useState')
  .named('useEffect')
  .from('react')

// With alias
tsImportBuilder()
  .named('createElement', 'h')
  .from('react')

// Type-only imports
tsImportBuilder()
  .typeOnly()
  .named('UserType')
  .from('@/types')
```

## 4. Migrating Template Rendering

### Old Approach
```typescript
const sentryFile = typescript.createTemplate(
  {
    SENTRY_SCOPE_ACTIONS: {
      type: 'code-block',
    },
  },
  { importMappers: [reactConfig] }
);

// Add content to the template
sentryFile.addCodeBlock('SENTRY_SCOPE_ACTIONS', block);

// Render the template
sentryFile.renderToAction('sentry.ts', sentryPath)
```

### New Approach
First, create a template definition file (usually in `generated/ts-templates.ts`):

```typescript
import { createTsTemplateFile } from '@halfdomelabs/core-generators';

const sentry = createTsTemplateFile({
  importMapProviders: { reactConfigImports: reactConfigImportsProvider },
  name: 'sentry',
  source: { path: 'sentry.ts' },
  variables: { TPL_SENTRY_SCOPE_ACTIONS: {} },
});

export const CORE_REACT_SENTRY_TS_TEMPLATES = { sentry };
```

Then use the template:

```typescript
// Render the template
await builder.apply(
  typescriptFile.renderTemplateFile({
    template: CORE_REACT_SENTRY_TS_TEMPLATES.sentry,
    destination: sentryPath,
    importMapProviders: {
      reactConfigImports,
    },
    variables: {
      TPL_SENTRY_SCOPE_ACTIONS: TsCodeUtils.mergeFragments(sentryScopeActions),
    },
  })
);
```

The template file should use `TPL_` prefix for variables:

```typescript
// In the template file
TPL_SENTRY_SCOPE_ACTIONS;
```

## 5. Refactoring Tasks

### Old Task Structure
```typescript
createGeneratorTask({
  dependencies: {
    typescript: typescriptProvider,
    reactConfig: reactConfigProvider,
  },
  exports: {
    reactSentry: reactSentryProvider.export(projectScope),
  },
  run({ typescript, reactConfig }) {
    // Initialize state
    const sentryFile = typescript.createTemplate(...);

    return {
      providers: {
        reactSentry: {
          addSentryScopeAction(block) {
            sentryFile.addCodeBlock('SENTRY_SCOPE_ACTIONS', block);
          },
        },
      },
      build: async (builder) => {
        await builder.apply(
          sentryFile.renderToAction('sentry.ts', sentryPath),
        );
      },
    };
  },
});
```

### New Task Structure
```typescript
// Config setup task
const [setupTask, reactSentryConfigProvider, reactSentryConfigValuesProvider] =
  createConfigProviderTask(
    (t) => ({
      sentryScopeActions: t.map<string, TsCodeFragment>(),
    }),
    {
      prefix: 'react-sentry',
      configScope: projectScope,
    }
  );

// Main task
createGeneratorTask({
  dependencies: {
    typescriptFile: typescriptFileProvider,
    reactConfigImports: reactConfigImportsProvider,
    reactSentryConfigValues: reactSentryConfigValuesProvider,
  },
  run({
    typescriptFile,
    reactConfigImports,
    reactSentryConfigValues: { sentryScopeActions },
  }) {
    return {
      build: async (builder) => {
        await builder.apply(
          typescriptFile.renderTemplateFile({
            template: CORE_REACT_SENTRY_TS_TEMPLATES.sentry,
            destination: sentryPath,
            importMapProviders: {
              reactConfigImports,
            },
            variables: {
              TPL_SENTRY_SCOPE_ACTIONS: TsCodeUtils.mergeFragments(sentryScopeActions),
            },
          }),
        );
      },
    };
  },
});
```

## 6. How to Choose Container Types in FieldMaps

When creating config providers, select the appropriate container type based on the data structure:

| Container Type | Use Case | Example |
|---------------|----------|---------|
| `t.scalar<T>()` | Single immutable value | `port: t.number(3000)` |
| `t.array<T>()` | Collection of items | `tags: t.array<string>(['default'])` |
| `t.map<K,V>()` | Key-value pairs | `routes: t.map<string, RouteConfig>()` |
| `t.object<T>()` | Complex object | `settings: t.object({ timeout: 5000 })` |
| `t.mapOfMaps<K1,K2,V>()` | Nested maps | `permissions: t.mapOfMaps<string,string,boolean>()` |

## 7. Path Handling

### Old Approach
```typescript
const [sentryImport, sentryPath] = makeImportAndFilePath(
  'src/services/sentry.ts',
);
```

### New Approach
```typescript
const sentryPath = '@/src/services/sentry.ts';
```

## TsCodeUtils Functions Reference

The `TsCodeUtils` object provides a comprehensive set of utility functions to simplify working with TypeScript code fragments:

| Function | Description | Example |
|----------|-------------|---------|
| `frag()` | Create a code fragment from a string | `TsCodeUtils.frag('const x = 1;')` |
| `importBuilder()` | Create an import builder | `TsCodeUtils.importBuilder(['User'])` |
| `importFragment()` | Create a fragment that imports from a module | `TsCodeUtils.importFragment('User', '@/types')` |
| `mergeFragments()` | Merge multiple fragments (from Map) | `TsCodeUtils.mergeFragments(fragmentsMap)` |
| `mergeFragmentsPresorted()` | Merge array of fragments | `TsCodeUtils.mergeFragmentsPresorted([f1, f2])` |
| `formatAsComment()` | Format text as a comment | `TsCodeUtils.formatAsComment('Note')` |
| `formatFragment()` | Create fragment with placeholders | `TsCodeUtils.formatFragment('func NAME() { BODY }', {...})` |
| `mergeFragmentsAsObject()` | Create object literal | `TsCodeUtils.mergeFragmentsAsObject({ prop: value })` |
| `mergeFragmentsAsInterfaceContent()` | Create interface properties | `TsCodeUtils.mergeFragmentsAsInterfaceContent({...})` |
| `mergeFragmentsAsArray()` | Create array literal | `TsCodeUtils.mergeFragmentsAsArray({...})` |
| `wrapFragment()` | Wrap fragment with template | `TsCodeUtils.wrapFragment(frag, 'try { CONTENTS }')` |
| `template` | Template literal function | ``TsCodeUtils.template`export const x = ${frag};` ``|
| `templateWithImports()` | Template with imports | `TsCodeUtils.templateWithImports(imports)`` `` |
| `mergeFragmentsAsJsxElement()` | Create JSX element | `TsCodeUtils.mergeFragmentsAsJsxElement('div', {...})` |

### Special Format Options for mergeFragmentsAsObject

- **Object Shorthand**: If the key matches the value, it becomes a shorthand property
  ```typescript
  // { value: 'value' } becomes { value, }
  ```

- **Function Shorthand**: Functions are automatically converted to method syntax
  ```typescript
  // { method: 'function method() {}' } becomes { method() {}, } 
  ```

- **Spread Operator**: Keys starting with '...' are treated as spreads
  ```typescript
  // { '...base': baseFragment } becomes { ...base, }
  ```

## Template Files Example

The new template system involves three key parts:

### 1. Template Source File
```typescript
// auth.plugin.ts (template source)
import type { AuthContext } from '%authContextImports';
import type { UserSessionService } from '%userSessionTypesImports';

import { createAuthContextFromSessionInfo } from '%authContextImports';
import { userSessionService } from '%userSessionServiceImports';
import { requestContext } from '@fastify/request-context';
import fp from 'fastify-plugin';

// ... plugin implementation ...
```

### 2. Template Definition File
```typescript
// generated/ts-templates.ts
import { createTsTemplateFile } from '@halfdomelabs/core-generators';

import { userSessionServiceImportsProvider } from '../../_providers/user-session.js';
import { authContextImportsProvider } from '../../auth-context/generated/ts-import-maps.js';
import { userSessionTypesImportsProvider } from '../../user-session-types/generated/ts-import-maps.js';

const authPlugin = createTsTemplateFile({
  importMapProviders: {
    authContextImports: authContextImportsProvider,
    userSessionServiceImports: userSessionServiceImportsProvider,
    userSessionTypesImports: userSessionTypesImportsProvider,
  },
  name: 'auth-plugin',
  projectExports: {},
  source: { path: 'auth.plugin.ts' },
  variables: {},
});

export const AUTH_AUTH_PLUGIN_TS_TEMPLATES = { authPlugin };
```

### 3. Template Usage in Generator
```typescript
await builder.apply(
  typescriptFile.renderTemplateFile({
    template: AUTH_AUTH_PLUGIN_TS_TEMPLATES.authPlugin,
    destination: authPluginPath,
    importMapProviders: {
      authContextImports,
      userSessionServiceImports,
      userSessionTypesImports,
    },
  })
);
```

## Common Pitfalls & Solutions

1. **Missing Hoisted Fragments**: If you have helper functions that need to be accessible throughout the file, use `tsHoistedFragment` with a unique key instead of `headerBlocks`.

2. **Import Order Issues**: Let the system handle import sorting by using `tsImportBuilder` consistently.

3. **Template Variables**: Always use the `TPL_` prefix for variables in templates.

4. **Provider Method Conversion**: Map imperative method calls to FieldMap operations:
   - `.add*()` → `.push()` or `.set()`
   - `.register*()` → `.set()`
   - `.get*()` → use the values provider

5. **Fragment Collection Merging**: Always use `TsCodeUtils.mergeFragments()` when combining multiple fragments.

## Step-by-Step Migration Process

1. **Identify Provider Patterns**: Analyze how your custom providers are used
2. **Create Config Provider Tasks**: Replace custom providers with FieldMap-based config providers
3. **Update Code Fragments**: Convert all `TypescriptCodeBlock` to `tsCodeFragment`
4. **Update Import Statements**: Replace string imports with `tsImportBuilder`
5. **Refactor Templates**: Create template definition files and update rendering logic
6. **Update Path Handling**: Use direct path strings instead of utility functions
7. **Test Generated Code**: Verify the output maintains the same functionality

By following this guide, you should be able to successfully migrate your TypeScript generators to the new system while maintaining or improving functionality.