import { camelCase, constantCase } from 'change-case';
import { execSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

export interface CreateGeneratorInput {
  name: string;
  directory: string;
  includeTemplates?: boolean;
}

export interface CreateGeneratorResult {
  message: string;
  generatorName: string;
  generatorPath: string;
  filesCreated: string[];
}

interface ParsedGeneratorName {
  category: string;
  kebabName: string;
  camelCaseName: string;
  screamingSnakeName: string;
}

/**
 * Parse a generator name in format "category/kebab-name" into its components
 */
function parseGeneratorName(name: string): ParsedGeneratorName {
  const [category, kebabName] = name.split('/');
  return {
    category,
    kebabName,
    camelCaseName: camelCase(kebabName),
    screamingSnakeName: constantCase(kebabName),
  };
}

/**
 * Generate the main generator file content
 */
function generateGeneratorFileContent(
  fullName: string,
  parsed: ParsedGeneratorName,
): string {
  return `import { createGenerator, createGeneratorTask } from '@baseplate-dev/sync';
import { z } from 'zod';

import { ${parsed.screamingSnakeName}_GENERATED } from './generated/index.js';

const descriptorSchema = z.object({});

/**
 * Generator for ${fullName}
 */
export const ${parsed.camelCaseName}Generator = createGenerator({
  name: '${fullName}',
  generatorFileUrl: import.meta.url,
  descriptorSchema,
  buildTasks: () => ({
    paths: ${parsed.screamingSnakeName}_GENERATED.paths.task,
    renderers: ${parsed.screamingSnakeName}_GENERATED.renderers.task,
    main: createGeneratorTask({
      dependencies: {
        renderers: ${parsed.screamingSnakeName}_GENERATED.renderers.provider,
      },
      run({ renderers }) {
        return {
          build: async (builder) => {
            // Add your generator logic here
          },
        };
      },
    }),
  }),
});
`;
}

/**
 * Generate the barrel export (index.ts) content
 */
function generateIndexFileContent(kebabName: string): string {
  return `export * from './${kebabName}.generator.js';
`;
}

/**
 * Generate the placeholder generated/index.ts content
 */
function generatePlaceholderGeneratedContent(
  parsed: ParsedGeneratorName,
): string {
  return `// This file is auto-generated by \`pnpm generate:templates\`
// Do not edit manually - run the command after adding templates
export const ${parsed.screamingSnakeName}_GENERATED = undefined as never;
`;
}

/**
 * Generate the extractor.json content
 */
function generateExtractorJsonContent(fullName: string): string {
  return JSON.stringify(
    {
      name: fullName,
      templates: {},
    },
    null,
    2,
  );
}

/**
 * Generate the category index.ts content or update existing one
 */
function generateOrUpdateCategoryIndex(
  categoryDir: string,
  kebabName: string,
): { content: string; isNew: boolean } {
  const indexPath = path.join(categoryDir, 'index.ts');
  const exportLine = `export * from './${kebabName}/index.js';`;

  if (fs.existsSync(indexPath)) {
    const existingContent = fs.readFileSync(indexPath, 'utf-8');
    if (existingContent.includes(exportLine)) {
      return { content: existingContent, isNew: false };
    }
    // Append the new export
    const newContent = `${existingContent.trimEnd()}\n${exportLine}\n`;
    return { content: newContent, isNew: false };
  }

  // Create new index file
  return { content: `${exportLine}\n`, isNew: true };
}

/**
 * Create a new generator with boilerplate code
 */
export function createGenerator(
  input: CreateGeneratorInput,
): CreateGeneratorResult {
  const { name, directory, includeTemplates = true } = input;

  // Parse the generator name
  const parsed = parseGeneratorName(name);

  // Resolve the absolute directory path
  const absoluteDirectory = path.isAbsolute(directory)
    ? directory
    : path.resolve(process.cwd(), directory);

  // Validate the directory exists
  if (!fs.existsSync(absoluteDirectory)) {
    throw new Error(`Directory does not exist: ${absoluteDirectory}`);
  }

  // Create the generator directory structure
  const categoryDir = path.join(absoluteDirectory, parsed.category);
  const generatorDir = path.join(categoryDir, parsed.kebabName);

  if (fs.existsSync(generatorDir)) {
    throw new Error(`Generator directory already exists: ${generatorDir}`);
  }

  const filesCreated: string[] = [];

  // Create directories
  fs.mkdirSync(generatorDir, { recursive: true });

  // Create the main generator file
  const generatorFilePath = path.join(
    generatorDir,
    `${parsed.kebabName}.generator.ts`,
  );
  fs.writeFileSync(
    generatorFilePath,
    generateGeneratorFileContent(name, parsed),
  );
  filesCreated.push(generatorFilePath);

  // Create the index.ts barrel export
  const indexFilePath = path.join(generatorDir, 'index.ts');
  fs.writeFileSync(indexFilePath, generateIndexFileContent(parsed.kebabName));
  filesCreated.push(indexFilePath);

  if (includeTemplates) {
    // Create the generated directory with placeholder
    const generatedDir = path.join(generatorDir, 'generated');
    fs.mkdirSync(generatedDir, { recursive: true });

    const generatedIndexPath = path.join(generatedDir, 'index.ts');
    fs.writeFileSync(
      generatedIndexPath,
      generatePlaceholderGeneratedContent(parsed),
    );
    filesCreated.push(generatedIndexPath);

    // Create extractor.json
    const extractorPath = path.join(generatorDir, 'extractor.json');
    fs.writeFileSync(extractorPath, generateExtractorJsonContent(name));
    filesCreated.push(extractorPath);
  }

  // Update or create the category index.ts
  const { content: categoryIndexContent, isNew: isCategoryNew } =
    generateOrUpdateCategoryIndex(categoryDir, parsed.kebabName);
  const categoryIndexPath = path.join(categoryDir, 'index.ts');
  fs.writeFileSync(categoryIndexPath, categoryIndexContent);
  if (isCategoryNew) {
    filesCreated.push(categoryIndexPath);
  }

  // Format the generated files with Prettier
  try {
    execSync(`pnpm prettier --write "${generatorDir}/**/*"`, {
      stdio: 'pipe',
      cwd: process.cwd(),
    });
  } catch {
    // Prettier formatting is best-effort, don't fail if it doesn't work
  }

  return {
    message: `Successfully created generator '${name}' at ${generatorDir}`,
    generatorName: name,
    generatorPath: generatorDir,
    filesCreated,
  };
}
